
build/waves.elf:     file format elf32-littlearm


Disassembly of section .text:

20000048 <_text_start>:
  (void)api;
}

__attribute__((weak))
void _hook_cycle(const user_osc_param_t * const params, int32_t *yn, const uint32_t frames)
{
20000048:	4770      	bx	lr

2000004a <_hook_mute>:
  (void)params;
}

__attribute__((weak))
void _hook_mute(const user_osc_param_t * const params)
{
2000004a:	4770      	bx	lr

2000004c <_hook_value>:
  (void)params;
}

__attribute__((weak))
void _hook_value(uint16_t value)
{
2000004c:	4770      	bx	lr
  (void)value;
}

__attribute__((weak))
void _hook_param(uint16_t index, uint16_t value)
{
2000004e:	4770      	bx	lr
20000050:	4770      	bx	lr
20000052:	4770      	bx	lr
  _hook_init(platform, api);
}

__attribute__((weak))
void _hook_init(uint32_t platform, uint32_t api)
{
20000054:	4770      	bx	lr

20000056 <_entry>:
 * @{
 */

__attribute__((used))
void _entry(uint32_t platform, uint32_t api)
{
20000056:	4b10      	ldr	r3, [pc, #64]	; (20000098 <_entry+0x42>)
20000058:	4a10      	ldr	r2, [pc, #64]	; (2000009c <_entry+0x46>)
2000005a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
2000005e:	4688      	mov	r8, r1
20000060:	4607      	mov	r7, r0
  // Ensure zero-clear BSS segment
  uint8_t * __restrict bss_p = (uint8_t *)&_bss_start;
  const uint8_t * const bss_e = (uint8_t *)&_bss_end;

  for (; bss_p != bss_e;)
    *(bss_p++) = 0;
20000062:	2100      	movs	r1, #0
{
  // Ensure zero-clear BSS segment
  uint8_t * __restrict bss_p = (uint8_t *)&_bss_start;
  const uint8_t * const bss_e = (uint8_t *)&_bss_end;

  for (; bss_p != bss_e;)
20000064:	4293      	cmp	r3, r2
20000066:	d002      	beq.n	2000006e <_entry+0x18>
    *(bss_p++) = 0;
20000068:	f803 1f01 	strb.w	r1, [r3, #1]!
2000006c:	e7fa      	b.n	20000064 <_entry+0xe>
2000006e:	4b0c      	ldr	r3, [pc, #48]	; (200000a0 <_entry+0x4a>)
20000070:	4c0c      	ldr	r4, [pc, #48]	; (200000a4 <_entry+0x4e>)
20000072:	1ae4      	subs	r4, r4, r3
20000074:	10a4      	asrs	r4, r4, #2

  // Call constructors if any.  
  const size_t count = __init_array_end - __init_array_start;
  for (size_t i = 0; i<count; ++i) {
20000076:	2500      	movs	r5, #0
20000078:	461e      	mov	r6, r3
2000007a:	42a5      	cmp	r5, r4
2000007c:	d005      	beq.n	2000008a <_entry+0x34>
    __init_fptr init_p = (__init_fptr)__init_array_start[i];
2000007e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
    if (init_p != NULL)
20000082:	b103      	cbz	r3, 20000086 <_entry+0x30>
      init_p();
20000084:	4798      	blx	r3
  for (; bss_p != bss_e;)
    *(bss_p++) = 0;

  // Call constructors if any.  
  const size_t count = __init_array_end - __init_array_start;
  for (size_t i = 0; i<count; ++i) {
20000086:	3501      	adds	r5, #1
20000088:	e7f7      	b.n	2000007a <_entry+0x24>
    if (init_p != NULL)
      init_p();
  }
  
  // Call user initialization
  _hook_init(platform, api);
2000008a:	4641      	mov	r1, r8
2000008c:	4638      	mov	r0, r7
2000008e:	f000 f80b 	bl	200000a8 <_hook_init>
20000092:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
20000096:	bf00      	nop
20000098:	200007ff 	.word	0x200007ff
2000009c:	2000088f 	.word	0x2000088f
200000a0:	20000040 	.word	0x20000040
200000a4:	20000044 	.word	0x20000044

200000a8 <_hook_init>:
#include "waves.hpp"

static Waves s_waves;

void OSC_INIT(uint32_t platform, uint32_t api)
{
200000a8:	4770      	bx	lr

200000aa <_hook_cycle>:
}

void OSC_CYCLE(const user_osc_param_t * const params,
               int32_t *yn,
               const uint32_t frames)
{
200000aa:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  Waves::State &s = s_waves.state;
  const Waves::Params &p = s_waves.params;

  // Handle events.
  {
    const uint32_t flags = s.flags;
200000ac:	4cc1      	ldr	r4, [pc, #772]	; (200003b4 <_hook_cycle+0x30a>)
    s.flags = Waves::k_flags_none;
    
    s_waves.updatePitch(osc_w0f_for_note((params->pitch)>>8, params->pitch & 0xFF));
200000ae:	8886      	ldrh	r6, [r0, #4]
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
200000b0:	4fc1      	ldr	r7, [pc, #772]	; (200003b8 <_hook_cycle+0x30e>)

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
200000b2:	eddf 6ac2 	vldr	s13, [pc, #776]	; 200003bc <_hook_cycle+0x312>
  const Waves::Params &p = s_waves.params;

  // Handle events.
  {
    const uint32_t flags = s.flags;
    s.flags = Waves::k_flags_none;
200000b6:	2300      	movs	r3, #0
}

void OSC_CYCLE(const user_osc_param_t * const params,
               int32_t *yn,
               const uint32_t frames)
{
200000b8:	460d      	mov	r5, r1
  Waves::State &s = s_waves.state;
  const Waves::Params &p = s_waves.params;

  // Handle events.
  {
    const uint32_t flags = s.flags;
200000ba:	f894 103c 	ldrb.w	r1, [r4, #60]	; 0x3c
    s.flags = Waves::k_flags_none;
200000be:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
    
    s_waves.updatePitch(osc_w0f_for_note((params->pitch)>>8, params->pitch & 0xFF));
200000c2:	1233      	asrs	r3, r6, #8
200000c4:	2b96      	cmp	r3, #150	; 0x96
200000c6:	b2f6      	uxtb	r6, r6
200000c8:	ee07 6a90 	vmov	s15, r6
200000cc:	bfd8      	it	le
200000ce:	461e      	movle	r6, r3
   * @param note Note in [0-151] range, mod in [0-255] range.
   * @return     Corresponding 0-1 phase increment in floating point.
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
200000d0:	f103 0301 	add.w	r3, r3, #1
200000d4:	b2db      	uxtb	r3, r3
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
200000d6:	bfc8      	it	gt
200000d8:	2697      	movgt	r6, #151	; 0x97
200000da:	2b96      	cmp	r3, #150	; 0x96
200000dc:	bf88      	it	hi
200000de:	2397      	movhi	r3, #151	; 0x97
200000e0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
200000e4:	eb07 0686 	add.w	r6, r7, r6, lsl #2
200000e8:	eb07 0383 	add.w	r3, r7, r3, lsl #2
200000ec:	ed96 7a00 	vldr	s14, [r6]
200000f0:	ee67 7aa6 	vmul.f32	s15, s15, s13
200000f4:	edd3 6a00 	vldr	s13, [r3]
200000f8:	ee76 6ac7 	vsub.f32	s13, s13, s14
}

void OSC_CYCLE(const user_osc_param_t * const params,
               int32_t *yn,
               const uint32_t frames)
{
200000fc:	ed2d 8b0e 	vpush	{d8-d14}
20000100:	eea7 7aa6 	vfma.f32	s14, s15, s13
    prelpf.mCoeffs.setPoleLP(0.8f);
    postlpf.mCoeffs.setFOLP(osc_tanpif(0.45f));
  }
  
  inline void updatePitch(float w0) {
    w0 += state.imperfection;
20000104:	eddf 6aae 	vldr	s13, [pc, #696]	; 200003c0 <_hook_cycle+0x316>
20000108:	eef0 7a47 	vmov.f32	s15, s14

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
2000010c:	ed9f 7aad 	vldr	s14, [pc, #692]	; 200003c4 <_hook_cycle+0x31a>
20000110:	eef4 7ac7 	vcmpe.f32	s15, s14
20000114:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000118:	bfa8      	it	ge
2000011a:	eef0 7a47 	vmovge.f32	s15, s14
2000011e:	ed94 7a0e 	vldr	s14, [r4, #56]	; 0x38
20000122:	eea7 7aa6 	vfma.f32	s14, s15, s13
    // Sub one octave and a phase drift (0.15Hz@48KHz)
    state.w0sub = 0.5f * w0 + drift * 3.125e-006f;
  }
    
  inline void updateWaves(const uint16_t flags) {
    if (flags & k_flag_wave0) {
20000126:	078e      	lsls	r6, r1, #30
    postlpf.mCoeffs.setFOLP(osc_tanpif(0.45f));
  }
  
  inline void updatePitch(float w0) {
    w0 += state.imperfection;
    const float drift = params.shiftshape;
20000128:	edd4 7a14 	vldr	s15, [r4, #80]	; 0x50
    state.w00 = w0;
    // Alt osc with slight drift (0.25Hz@48KHz)
    state.w01 = w0 + drift * 5.20833333333333e-006f;
2000012c:	eddf 6aa6 	vldr	s13, [pc, #664]	; 200003c8 <_hook_cycle+0x31e>
  }
  
  inline void updatePitch(float w0) {
    w0 += state.imperfection;
    const float drift = params.shiftshape;
    state.w00 = w0;
20000130:	ed84 7a06 	vstr	s14, [r4, #24]
    // Alt osc with slight drift (0.25Hz@48KHz)
    state.w01 = w0 + drift * 5.20833333333333e-006f;
20000134:	eeb0 6a47 	vmov.f32	s12, s14
20000138:	eea7 6aa6 	vfma.f32	s12, s15, s13
    // Sub one octave and a phase drift (0.15Hz@48KHz)
    state.w0sub = 0.5f * w0 + drift * 3.125e-006f;
2000013c:	eddf 6aa3 	vldr	s13, [pc, #652]	; 200003cc <_hook_cycle+0x322>
  inline void updatePitch(float w0) {
    w0 += state.imperfection;
    const float drift = params.shiftshape;
    state.w00 = w0;
    // Alt osc with slight drift (0.25Hz@48KHz)
    state.w01 = w0 + drift * 5.20833333333333e-006f;
20000140:	ed84 6a07 	vstr	s12, [r4, #28]
    // Sub one octave and a phase drift (0.15Hz@48KHz)
    state.w0sub = 0.5f * w0 + drift * 3.125e-006f;
20000144:	ee67 7aa6 	vmul.f32	s15, s15, s13
20000148:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
2000014c:	eee7 7a26 	vfma.f32	s15, s14, s13
20000150:	edc4 7a08 	vstr	s15, [r4, #32]
  }
    
  inline void updateWaves(const uint16_t flags) {
    if (flags & k_flag_wave0) {
20000154:	d511      	bpl.n	2000017a <_hook_cycle+0xd0>
      static const uint8_t k_a_thr = k_waves_a_cnt;
      static const uint8_t k_b_thr = k_a_thr + k_waves_b_cnt;
      static const uint8_t k_c_thr = k_b_thr + k_waves_c_cnt;
      
      uint8_t idx = params.wave0;
20000156:	f894 3054 	ldrb.w	r3, [r4, #84]	; 0x54
      const float * const * table;
      
      if (idx < k_a_thr) {
2000015a:	2b0f      	cmp	r3, #15
2000015c:	d909      	bls.n	20000172 <_hook_cycle+0xc8>
        table = wavesA;
      }
      else if (idx < k_b_thr) {
2000015e:	2b1f      	cmp	r3, #31
        table = wavesB;
        idx -= k_a_thr;
20000160:	bf97      	itett	ls
20000162:	3b10      	subls	r3, #16
      }
      else { 
        table = wavesC;
        idx -= k_b_thr;
20000164:	3b20      	subhi	r3, #32
      if (idx < k_a_thr) {
        table = wavesA;
      }
      else if (idx < k_b_thr) {
        table = wavesB;
        idx -= k_a_thr;
20000166:	b2db      	uxtbls	r3, r3
      
      if (idx < k_a_thr) {
        table = wavesA;
      }
      else if (idx < k_b_thr) {
        table = wavesB;
20000168:	4e99      	ldrls	r6, [pc, #612]	; (200003d0 <_hook_cycle+0x326>)
        idx -= k_a_thr;
      }
      else { 
        table = wavesC;
2000016a:	bf84      	itt	hi
2000016c:	4e99      	ldrhi	r6, [pc, #612]	; (200003d4 <_hook_cycle+0x32a>)
        idx -= k_b_thr;
2000016e:	b2db      	uxtbhi	r3, r3
20000170:	e000      	b.n	20000174 <_hook_cycle+0xca>
      
      uint8_t idx = params.wave0;
      const float * const * table;
      
      if (idx < k_a_thr) {
        table = wavesA;
20000172:	4e99      	ldr	r6, [pc, #612]	; (200003d8 <_hook_cycle+0x32e>)
      }
      else { 
        table = wavesC;
        idx -= k_b_thr;
      }
      state.wave0 = table[idx];
20000174:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
20000178:	6023      	str	r3, [r4, #0]
    }
    if (flags & k_flag_wave1) {
2000017a:	074b      	lsls	r3, r1, #29
2000017c:	d511      	bpl.n	200001a2 <_hook_cycle+0xf8>
      static const uint8_t k_d_thr = k_waves_d_cnt;
      static const uint8_t k_e_thr = k_d_thr + k_waves_e_cnt;
      static const uint8_t k_f_thr = k_e_thr + k_waves_f_cnt;
      
      uint8_t idx = params.wave1;
2000017e:	f894 3055 	ldrb.w	r3, [r4, #85]	; 0x55
      const float * const * table;
      
      if (idx < k_d_thr) {
20000182:	2b0c      	cmp	r3, #12
20000184:	d909      	bls.n	2000019a <_hook_cycle+0xf0>
        table = wavesD;
      }
      else if (idx < k_e_thr) {
20000186:	2b1b      	cmp	r3, #27
        table = wavesE;
        idx -= k_d_thr;
20000188:	bf97      	itett	ls
2000018a:	3b0d      	subls	r3, #13
      }
      else { // if (idx < k_f_thr) {
        table = wavesF;
        idx -= k_e_thr;
2000018c:	3b1c      	subhi	r3, #28
      if (idx < k_d_thr) {
        table = wavesD;
      }
      else if (idx < k_e_thr) {
        table = wavesE;
        idx -= k_d_thr;
2000018e:	b2db      	uxtbls	r3, r3
      
      if (idx < k_d_thr) {
        table = wavesD;
      }
      else if (idx < k_e_thr) {
        table = wavesE;
20000190:	4e92      	ldrls	r6, [pc, #584]	; (200003dc <_hook_cycle+0x332>)
        idx -= k_d_thr;
      }
      else { // if (idx < k_f_thr) {
        table = wavesF;
20000192:	bf84      	itt	hi
20000194:	4e92      	ldrhi	r6, [pc, #584]	; (200003e0 <_hook_cycle+0x336>)
        idx -= k_e_thr;
20000196:	b2db      	uxtbhi	r3, r3
20000198:	e000      	b.n	2000019c <_hook_cycle+0xf2>
      
      uint8_t idx = params.wave1;
      const float * const * table;
      
      if (idx < k_d_thr) {
        table = wavesD;
2000019a:	4e92      	ldr	r6, [pc, #584]	; (200003e4 <_hook_cycle+0x33a>)
      else { // if (idx < k_f_thr) {
        table = wavesF;
        idx -= k_e_thr;
      }
      
      state.wave1 = table[idx];
2000019c:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
200001a0:	6063      	str	r3, [r4, #4]
    }
    if (flags & k_flag_subwave) {
200001a2:	070f      	lsls	r7, r1, #28
      const uint8_t idx = params.subwave;
      state.subwave = wavesA[params.subwave];
200001a4:	bf44      	itt	mi
200001a6:	4b8c      	ldrmi	r3, [pc, #560]	; (200003d8 <_hook_cycle+0x32e>)
200001a8:	f894 6056 	ldrbmi.w	r6, [r4, #86]	; 0x56
    s_waves.updateWaves(flags);
    
    if (flags & Waves::k_flag_reset)
      s.reset();
    
    s.lfo = q31_to_f32(params->shape_lfo);
200001ac:	ed90 7a00 	vldr	s14, [r0]
200001b0:	bf44      	itt	mi
200001b2:	f853 3026 	ldrmi.w	r3, [r3, r6, lsl #2]
200001b6:	60a3      	strmi	r3, [r4, #8]
    
    s_waves.updatePitch(osc_w0f_for_note((params->pitch)>>8, params->pitch & 0xFF));
    
    s_waves.updateWaves(flags);
    
    if (flags & Waves::k_flag_reset)
200001b8:	064e      	lsls	r6, r1, #25
      imperfection = osc_white() * 1.0417e-006f; // +/- 0.05Hz@48KHz
    }
    
    inline void reset(void)
    {
      phi0 = 0;
200001ba:	bf48      	it	mi
200001bc:	2300      	movmi	r3, #0
      s.reset();
    
    s.lfo = q31_to_f32(params->shape_lfo);
200001be:	eeba 7ae0 	vcvt.f32.s32	s14, s14, #31
200001c2:	bf42      	ittt	mi
200001c4:	60e3      	strmi	r3, [r4, #12]
      phi1 = 0;
200001c6:	6123      	strmi	r3, [r4, #16]
      phisub = 0;
200001c8:	6163      	strmi	r3, [r4, #20]

    if (flags & Waves::k_flag_bitcrush) {
200001ca:	0689      	lsls	r1, r1, #26
    s_waves.updateWaves(flags);
    
    if (flags & Waves::k_flag_reset)
      s.reset();
    
    s.lfo = q31_to_f32(params->shape_lfo);
200001cc:	4b79      	ldr	r3, [pc, #484]	; (200003b4 <_hook_cycle+0x30a>)
200001ce:	ed84 7a09 	vstr	s14, [r4, #36]	; 0x24

    if (flags & Waves::k_flag_bitcrush) {
200001d2:	d52a      	bpl.n	2000022a <_hook_cycle+0x180>
      s.dither = p.bitcrush * 2e-008f;
200001d4:	edd3 7a12 	vldr	s15, [r3, #72]	; 0x48
200001d8:	eddf 6a83 	vldr	s13, [pc, #524]	; 200003e8 <_hook_cycle+0x33e>
   * @note       Fractional bit depth, exponentially mapped, 1 to 24 bits.
   */
  __fast_inline float osc_bitresf(float x) {
    const float xf = x * k_bitres_size;
    const uint32_t xi = (uint32_t)xf;
    const float y0 = bitres_lut_f[xi];
200001dc:	4983      	ldr	r1, [pc, #524]	; (200003ec <_hook_cycle+0x342>)
200001de:	ee67 6aa6 	vmul.f32	s13, s15, s13
200001e2:	edc3 6a0b 	vstr	s13, [r3, #44]	; 0x2c
   * @param   x  Value in [0, 1.0].
   * @return     Quantization scaling factor.
   * @note       Fractional bit depth, exponentially mapped, 1 to 24 bits.
   */
  __fast_inline float osc_bitresf(float x) {
    const float xf = x * k_bitres_size;
200001e6:	eddf 6a82 	vldr	s13, [pc, #520]	; 200003f0 <_hook_cycle+0x346>
200001ea:	ee67 7aa6 	vmul.f32	s15, s15, s13
    const uint32_t xi = (uint32_t)xf;
200001ee:	eefc 6ae7 	vcvt.u32.f32	s13, s15
200001f2:	ee16 0a90 	vmov	r0, s13

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
200001f6:	ee06 0a10 	vmov	s12, r0
200001fa:	eeb8 6a46 	vcvt.f32.u32	s12, s12
    const float y0 = bitres_lut_f[xi];
200001fe:	eb01 0680 	add.w	r6, r1, r0, lsl #2
20000202:	ee77 7ac6 	vsub.f32	s15, s15, s12
20000206:	edd6 6a00 	vldr	s13, [r6]
2000020a:	ed96 6a01 	vldr	s12, [r6, #4]
2000020e:	ee36 6a66 	vsub.f32	s12, s12, s13
20000212:	eee7 6a86 	vfma.f32	s13, s15, s12
      s.bitres = osc_bitresf(p.bitcrush);
      s.bitresrcp = 1.f / s.bitres;
20000216:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
2000021a:	eef0 7a66 	vmov.f32	s15, s13
    
    s.lfo = q31_to_f32(params->shape_lfo);

    if (flags & Waves::k_flag_bitcrush) {
      s.dither = p.bitcrush * 2e-008f;
      s.bitres = osc_bitresf(p.bitcrush);
2000021e:	edc3 6a0c 	vstr	s13, [r3, #48]	; 0x30
      s.bitresrcp = 1.f / s.bitres;
20000222:	eec6 6a27 	vdiv.f32	s13, s12, s15
20000226:	edc3 6a0d 	vstr	s13, [r3, #52]	; 0x34
  // Temporaries.
  float phi0 = s.phi0;
  float phi1 = s.phi1;
  float phisub = s.phisub;

  float lfoz = s.lfoz;
2000022a:	ed94 aa0a 	vldr	s20, [r4, #40]	; 0x28
      s.bitresrcp = 1.f / s.bitres;
    }
  }
  
  // Temporaries.
  float phi0 = s.phi0;
2000022e:	edd4 9a03 	vldr	s19, [r4, #12]
  float phi1 = s.phi1;
20000232:	ed94 9a04 	vldr	s18, [r4, #16]
  float phisub = s.phisub;
20000236:	edd4 8a05 	vldr	s17, [r4, #20]
  const float ditheramt = p.bitcrush * 2e-008f;
  
  const float bitres = osc_bitresf(p.bitcrush);
  const float bitres_recip = 1.f / bitres;

  const float submix = p.submix;
2000023a:	edd4 aa10 	vldr	s21, [r4, #64]	; 0x40
  const float ringmix = p.ringmix;
2000023e:	ed94 ba11 	vldr	s22, [r4, #68]	; 0x44

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000242:	eddf ba6c 	vldr	s23, [pc, #432]	; 200003f4 <_hook_cycle+0x34a>
20000246:	ed9f ca6c 	vldr	s24, [pc, #432]	; 200003f8 <_hook_cycle+0x34e>
  float phi0 = s.phi0;
  float phi1 = s.phi1;
  float phisub = s.phisub;

  float lfoz = s.lfoz;
  const float lfo_inc = (s.lfo - lfoz) / frames;
2000024a:	ee07 2a90 	vmov	s15, r2
2000024e:	ee37 7a4a 	vsub.f32	s14, s14, s20
20000252:	eef8 7a67 	vcvt.f32.u32	s15, s15
  
  dsp::BiQuad &prelpf = s_waves.prelpf;
  dsp::BiQuad &postlpf = s_waves.postlpf;
  
  q31_t * __restrict y = (q31_t *)yn;
  const q31_t * y_e = y + frames;
20000256:	eb05 0682 	add.w	r6, r5, r2, lsl #2
  float phi0 = s.phi0;
  float phi1 = s.phi1;
  float phisub = s.phisub;

  float lfoz = s.lfoz;
  const float lfo_inc = (s.lfo - lfoz) / frames;
2000025a:	eec7 ca27 	vdiv.f32	s25, s14, s15
  dsp::BiQuad &postlpf = s_waves.postlpf;
  
  q31_t * __restrict y = (q31_t *)yn;
  const q31_t * y_e = y + frames;
  
  for (; y != y_e; ) {
2000025e:	42b5      	cmp	r5, r6
20000260:	f000 814a 	beq.w	200004f8 <_hook_cycle+0x44e>

    const float wavemix = clipminmaxf(0.005f, p.shape+lfoz, 0.995f);
    
    float sig = (1.f - wavemix) * osc_wave_scanf(s.wave0, phi0);
20000264:	6822      	ldr	r2, [r4, #0]
    sig += wavemix * osc_wave_scanf(s.wave1, phi1);
20000266:	6860      	ldr	r0, [r4, #4]
  q31_t * __restrict y = (q31_t *)yn;
  const q31_t * y_e = y + frames;
  
  for (; y != y_e; ) {

    const float wavemix = clipminmaxf(0.005f, p.shape+lfoz, 0.995f);
20000268:	edd4 6a13 	vldr	s13, [r4, #76]	; 0x4c
  extern const float * const wavesF[k_waves_f_cnt];
  
  static inline __attribute__((always_inline, optimize("Ofast")))
  float osc_wave_scanf(const float *w, float x) {
    const float p = x - (uint32_t)x;
    const float x0f = p * k_waves_size;
2000026c:	ed9f 7a60 	vldr	s14, [pc, #384]	; 200003f0 <_hook_cycle+0x346>
20000270:	ee7a 6a26 	vadd.f32	s13, s20, s13
20000274:	eebc 6ac9 	vcvt.u32.f32	s12, s18
20000278:	ee76 7aeb 	vsub.f32	s15, s13, s23
2000027c:	eeb8 6a46 	vcvt.f32.u32	s12, s12
20000280:	eef5 7ac0 	vcmpe.f32	s15, #0.0
20000284:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000288:	bfb8      	it	lt
2000028a:	eef0 6a6b 	vmovlt.f32	s13, s23
2000028e:	ee76 7acc 	vsub.f32	s15, s13, s24
20000292:	ee39 6a46 	vsub.f32	s12, s18, s12
20000296:	eef5 7a40 	vcmp.f32	s15, #0.0
2000029a:	eefc 7ae9 	vcvt.u32.f32	s15, s19
2000029e:	ee26 6a07 	vmul.f32	s12, s12, s14
200002a2:	eef8 7a67 	vcvt.f32.u32	s15, s15
    const uint32_t x0 = ((uint32_t)x0f) & k_waves_mask;
200002a6:	eefc 3ac6 	vcvt.u32.f32	s7, s12
  extern const float * const wavesF[k_waves_f_cnt];
  
  static inline __attribute__((always_inline, optimize("Ofast")))
  float osc_wave_scanf(const float *w, float x) {
    const float p = x - (uint32_t)x;
    const float x0f = p * k_waves_size;
200002aa:	ee79 7ae7 	vsub.f32	s15, s19, s15
200002ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200002b2:	ee67 7a87 	vmul.f32	s15, s15, s14
    
    float sig = (1.f - wavemix) * osc_wave_scanf(s.wave0, phi0);
    sig += wavemix * osc_wave_scanf(s.wave1, phi1);
200002b6:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
    const uint32_t x0 = ((uint32_t)x0f) & k_waves_mask;
200002ba:	eebc 4ae7 	vcvt.u32.f32	s8, s15
200002be:	bfa8      	it	ge
200002c0:	eef0 6a4c 	vmovge.f32	s13, s24
200002c4:	ee14 3a10 	vmov	r3, s8
200002c8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    const uint32_t x1 = (x0 + 1) & k_waves_mask;
    return linintf(x0f - (uint32_t)x0f, w[x0], w[x1]);
200002cc:	eb02 0183 	add.w	r1, r2, r3, lsl #2
200002d0:	edd1 4a00 	vldr	s9, [r1]
  
  static inline __attribute__((always_inline, optimize("Ofast")))
  float osc_wave_scanf(const float *w, float x) {
    const float p = x - (uint32_t)x;
    const float x0f = p * k_waves_size;
    const uint32_t x0 = ((uint32_t)x0f) & k_waves_mask;
200002d4:	ee13 1a90 	vmov	r1, s7
200002d8:	f001 017f 	and.w	r1, r1, #127	; 0x7f
    const uint32_t x1 = (x0 + 1) & k_waves_mask;
    return linintf(x0f - (uint32_t)x0f, w[x0], w[x1]);
200002dc:	eb00 0781 	add.w	r7, r0, r1, lsl #2
200002e0:	3101      	adds	r1, #1
200002e2:	eef8 3a63 	vcvt.f32.u32	s7, s7
200002e6:	f001 017f 	and.w	r1, r1, #127	; 0x7f
200002ea:	eb00 0181 	add.w	r1, r0, r1, lsl #2
200002ee:	ee36 6a63 	vsub.f32	s12, s12, s7
200002f2:	ed97 5a00 	vldr	s10, [r7]
200002f6:	edd1 3a00 	vldr	s7, [r1]
200002fa:	3301      	adds	r3, #1
200002fc:	ee73 3ac5 	vsub.f32	s7, s7, s10
20000300:	f003 037f 	and.w	r3, r3, #127	; 0x7f
20000304:	eb02 0383 	add.w	r3, r2, r3, lsl #2
20000308:	eea6 5a23 	vfma.f32	s10, s12, s7
    
    const float subsig = osc_wave_scanf(s.subwave, phisub);
2000030c:	68a2      	ldr	r2, [r4, #8]
  for (; y != y_e; ) {

    const float wavemix = clipminmaxf(0.005f, p.shape+lfoz, 0.995f);
    
    float sig = (1.f - wavemix) * osc_wave_scanf(s.wave0, phi0);
    sig += wavemix * osc_wave_scanf(s.wave1, phi1);
2000030e:	ed93 6a00 	vldr	s12, [r3]
20000312:	eeb8 4a44 	vcvt.f32.u32	s8, s8
20000316:	ee36 6a64 	vsub.f32	s12, s12, s9
2000031a:	ee77 7ac4 	vsub.f32	s15, s15, s8
2000031e:	ee35 3ae6 	vsub.f32	s6, s11, s13
20000322:	eee7 4a86 	vfma.f32	s9, s15, s12
  extern const float * const wavesF[k_waves_f_cnt];
  
  static inline __attribute__((always_inline, optimize("Ofast")))
  float osc_wave_scanf(const float *w, float x) {
    const float p = x - (uint32_t)x;
    const float x0f = p * k_waves_size;
20000326:	eefc 7ae8 	vcvt.u32.f32	s15, s17
2000032a:	ee65 6a26 	vmul.f32	s13, s10, s13
2000032e:	eef8 7a67 	vcvt.f32.u32	s15, s15
20000332:	eee3 6a24 	vfma.f32	s13, s6, s9
20000336:	ee78 7ae7 	vsub.f32	s15, s17, s15
2000033a:	eeb0 da65 	vmov.f32	s26, s11
2000033e:	ee27 7a87 	vmul.f32	s14, s15, s14
20000342:	eeff da00 	vmov.f32	s27, #240	; 0xbf800000 -1.0
    const uint32_t x0 = ((uint32_t)x0f) & k_waves_mask;
20000346:	eebc 6ac7 	vcvt.u32.f32	s12, s14
2000034a:	ee16 3a10 	vmov	r3, s12
2000034e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    const uint32_t x1 = (x0 + 1) & k_waves_mask;
    return linintf(x0f - (uint32_t)x0f, w[x0], w[x1]);
20000352:	eb02 0183 	add.w	r1, r2, r3, lsl #2
20000356:	3301      	adds	r3, #1

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000358:	eeb8 6a46 	vcvt.f32.u32	s12, s12
2000035c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
20000360:	eb02 0383 	add.w	r3, r2, r3, lsl #2
20000364:	ee37 7a46 	vsub.f32	s14, s14, s12
20000368:	edd1 7a00 	vldr	s15, [r1]
2000036c:	ed93 6a00 	vldr	s12, [r3]
20000370:	ee36 6a67 	vsub.f32	s12, s12, s15
20000374:	eee7 7a06 	vfma.f32	s15, s14, s12
    
    const float subsig = osc_wave_scanf(s.subwave, phisub);
    sig = (1.f - submix) * sig + submix * subsig;
20000378:	ee35 6aea 	vsub.f32	s12, s11, s21
2000037c:	ee2a 7aa7 	vmul.f32	s14, s21, s15
20000380:	eea6 7a86 	vfma.f32	s14, s13, s12
    sig = (1.f - ringmix) * sig + ringmix * (subsig * sig);
20000384:	ee75 6acb 	vsub.f32	s13, s11, s22
20000388:	ee67 7a27 	vmul.f32	s15, s14, s15
2000038c:	ee67 7a8b 	vmul.f32	s15, s15, s22
20000390:	eee7 7a26 	vfma.f32	s15, s14, s13

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000394:	ee37 7aa5 	vadd.f32	s14, s15, s11
20000398:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
2000039c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200003a0:	db2c      	blt.n	200003fc <_hook_cycle+0x352>
200003a2:	eef4 7ae5 	vcmpe.f32	s15, s11
200003a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200003aa:	bfa8      	it	ge
200003ac:	eef0 7a65 	vmovge.f32	s15, s11
200003b0:	e026      	b.n	20000400 <_hook_cycle+0x356>
200003b2:	bf00      	nop
200003b4:	20000800 	.word	0x20000800
200003b8:	0800f100 	.word	0x0800f100
200003bc:	3b808081 	.word	0x3b808081
200003c0:	37aec33e 	.word	0x37aec33e
200003c4:	46b8ff49 	.word	0x46b8ff49
200003c8:	36aec33e 	.word	0x36aec33e
200003cc:	3651b717 	.word	0x3651b717
200003d0:	0801546c 	.word	0x0801546c
200003d4:	080174ec 	.word	0x080174ec
200003d8:	080131e8 	.word	0x080131e8
200003dc:	0801abc4 	.word	0x0801abc4
200003e0:	0801ca3c 	.word	0x0801ca3c
200003e4:	0801915c 	.word	0x0801915c
200003e8:	32abcc77 	.word	0x32abcc77
200003ec:	0800ff6c 	.word	0x0800ff6c
200003f0:	43000000 	.word	0x43000000
200003f4:	3ba3d70a 	.word	0x3ba3d70a
200003f8:	3f7eb852 	.word	0x3f7eb852
200003fc:	eef0 7a6d 	vmov.f32	s15, s27
     *
     * @return Output sample
     */
    inline __attribute__((optimize("Ofast"),always_inline))
    float process_fo(const float xn) {
      float acc = mCoeffs.ff0 * xn + mZ1;
20000400:	ed94 7a16 	vldr	s14, [r4, #88]	; 0x58
20000404:	ed94 8a1b 	vldr	s16, [r4, #108]	; 0x6c
      mZ1 = mCoeffs.ff1 * xn;
      mZ1 -= mCoeffs.fb1 * acc;
20000408:	edd4 6a17 	vldr	s13, [r4, #92]	; 0x5c
    sig = clip1m1f(sig);
    
    sig = prelpf.process_fo(sig);
    sig += s.dither * osc_white();
2000040c:	ed94 ea0b 	vldr	s28, [r4, #44]	; 0x2c
     *
     * @return Output sample
     */
    inline __attribute__((optimize("Ofast"),always_inline))
    float process_fo(const float xn) {
      float acc = mCoeffs.ff0 * xn + mZ1;
20000410:	eea7 8a27 	vfma.f32	s16, s14, s15
      mZ1 = mCoeffs.ff1 * xn;
      mZ1 -= mCoeffs.fb1 * acc;
20000414:	ed94 7a19 	vldr	s14, [r4, #100]	; 0x64
20000418:	ee27 7a48 	vnmul.f32	s14, s14, s16
2000041c:	eea6 7aa7 	vfma.f32	s14, s13, s15
20000420:	ed84 7a1b 	vstr	s14, [r4, #108]	; 0x6c
   * @return     Value in [-1.0, 1.0].
   */
  float _osc_white(void);

  __fast_inline float osc_white(void) {
    return _osc_white();
20000424:	f000 f9e8 	bl	200007f8 <___osc_white_veneer>
    sig = si_roundf(sig * s.bitres) * s.bitresrcp;
20000428:	eeae 8a00 	vfma.f32	s16, s28, s0
2000042c:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
     *
     * @return Output sample
     */
    inline __attribute__((optimize("Ofast"),always_inline))
    float process_fo(const float xn) {
      float acc = mCoeffs.ff0 * xn + mZ1;
20000430:	ed94 7a1d 	vldr	s14, [r4, #116]	; 0x74
20000434:	edd4 6a22 	vldr	s13, [r4, #136]	; 0x88
      mZ1 = mCoeffs.ff1 * xn;
      mZ1 -= mCoeffs.fb1 * acc;
20000438:	ed94 6a1e 	vldr	s12, [r4, #120]	; 0x78
2000043c:	ee28 8a27 	vmul.f32	s16, s16, s15
{
  f32_t xs = {x};
  f32_t ys = {y};
  
  xs.i &= 0x7fffffff;
  xs.i |= ys.i & 0x80000000;
20000440:	ee18 3a10 	vmov	r3, s16
20000444:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
20000448:	f043 537c 	orr.w	r3, r3, #1056964608	; 0x3f000000
2000044c:	ee07 3a90 	vmov	s15, r3
20000450:	ee38 8a27 	vadd.f32	s16, s16, s15
20000454:	edd4 7a0d 	vldr	s15, [r4, #52]	; 0x34
20000458:	eebd 8ac8 	vcvt.s32.f32	s16, s16
2000045c:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
20000460:	ee68 7a27 	vmul.f32	s15, s16, s15
     *
     * @return Output sample
     */
    inline __attribute__((optimize("Ofast"),always_inline))
    float process_fo(const float xn) {
      float acc = mCoeffs.ff0 * xn + mZ1;
20000464:	eee7 6a87 	vfma.f32	s13, s15, s14
      mZ1 = mCoeffs.ff1 * xn;
      mZ1 -= mCoeffs.fb1 * acc;
20000468:	ed94 7a20 	vldr	s14, [r4, #128]	; 0x80
2000046c:	ee27 7a66 	vnmul.f32	s14, s14, s13

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000470:	eef4 6aed 	vcmpe.f32	s13, s27
20000474:	eea7 7a86 	vfma.f32	s14, s15, s12
20000478:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
2000047c:	ed84 7a22 	vstr	s14, [r4, #136]	; 0x88
20000480:	db0b      	blt.n	2000049a <_hook_cycle+0x3f0>
20000482:	eef4 6acd 	vcmpe.f32	s13, s26
20000486:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
2000048a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
2000048e:	bfb4      	ite	lt
20000490:	eef0 7a66 	vmovlt.f32	s15, s13
20000494:	eef0 7a47 	vmovge.f32	s15, s14
20000498:	e001      	b.n	2000049e <_hook_cycle+0x3f4>
2000049a:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
    sig = postlpf.process_fo(sig);
    sig = osc_softclipf(0.125f, sig);
    
    *(y++) = f32_to_q31(sig);
2000049e:	ee27 7aa7 	vmul.f32	s14, s15, s15
200004a2:	eef4 6a00 	vmov.f32	s13, #64	; 0x3e000000  0.125
200004a6:	ee27 7ac7 	vnmul.f32	s14, s15, s14
    phi0 -= (uint32_t)phi0;
    phi1 += s.w01;
    phi1 -= (uint32_t)phi1;
    phisub += s.w0sub;
    phisub -= (uint32_t)phisub;
    lfoz += lfo_inc;
200004aa:	ee3a aa2c 	vadd.f32	s20, s20, s25
    sig += s.dither * osc_white();
    sig = si_roundf(sig * s.bitres) * s.bitresrcp;
    sig = postlpf.process_fo(sig);
    sig = osc_softclipf(0.125f, sig);
    
    *(y++) = f32_to_q31(sig);
200004ae:	eee7 7a26 	vfma.f32	s15, s14, s13
200004b2:	eefe 7ae0 	vcvt.s32.f32	s15, s15, #31
200004b6:	ece5 7a01 	vstmia	r5!, {s15}
    
    phi0 += s.w00;
200004ba:	edd4 7a06 	vldr	s15, [r4, #24]
200004be:	ee79 9aa7 	vadd.f32	s19, s19, s15
    phi0 -= (uint32_t)phi0;
200004c2:	eefc 7ae9 	vcvt.u32.f32	s15, s19
200004c6:	eef8 7a67 	vcvt.f32.u32	s15, s15
200004ca:	ee79 9ae7 	vsub.f32	s19, s19, s15
    phi1 += s.w01;
200004ce:	edd4 7a07 	vldr	s15, [r4, #28]
200004d2:	ee39 9a27 	vadd.f32	s18, s18, s15
    phi1 -= (uint32_t)phi1;
200004d6:	eefc 7ac9 	vcvt.u32.f32	s15, s18
200004da:	eef8 7a67 	vcvt.f32.u32	s15, s15
200004de:	ee39 9a67 	vsub.f32	s18, s18, s15
    phisub += s.w0sub;
200004e2:	edd4 7a08 	vldr	s15, [r4, #32]
200004e6:	ee78 8aa7 	vadd.f32	s17, s17, s15
    phisub -= (uint32_t)phisub;
200004ea:	eefc 7ae8 	vcvt.u32.f32	s15, s17
200004ee:	eef8 7a67 	vcvt.f32.u32	s15, s15
200004f2:	ee78 8ae7 	vsub.f32	s17, s17, s15
  dsp::BiQuad &postlpf = s_waves.postlpf;
  
  q31_t * __restrict y = (q31_t *)yn;
  const q31_t * y_e = y + frames;
  
  for (; y != y_e; ) {
200004f6:	e6b2      	b.n	2000025e <_hook_cycle+0x1b4>
    phisub += s.w0sub;
    phisub -= (uint32_t)phisub;
    lfoz += lfo_inc;
  }
  
  s.phi0 = phi0;
200004f8:	edc4 9a03 	vstr	s19, [r4, #12]
  s.phi1 = phi1;
200004fc:	ed84 9a04 	vstr	s18, [r4, #16]
  s.phisub = phisub;
20000500:	edc4 8a05 	vstr	s17, [r4, #20]
  s.lfoz = lfoz;
20000504:	ed84 aa0a 	vstr	s20, [r4, #40]	; 0x28
}
20000508:	ecbd 8b0e 	vpop	{d8-d14}
2000050c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

2000050e <_hook_on>:

void OSC_NOTEON(const user_osc_param_t * const params)
{
  s_waves.state.flags |= Waves::k_flag_reset;
2000050e:	4a04      	ldr	r2, [pc, #16]	; (20000520 <_hook_on+0x12>)
20000510:	f892 303c 	ldrb.w	r3, [r2, #60]	; 0x3c
20000514:	f043 0340 	orr.w	r3, r3, #64	; 0x40
20000518:	f882 303c 	strb.w	r3, [r2, #60]	; 0x3c
2000051c:	4770      	bx	lr
2000051e:	bf00      	nop
20000520:	20000800 	.word	0x20000800

20000524 <_hook_off>:
}

void OSC_NOTEOFF(const user_osc_param_t * const params)
{
20000524:	4770      	bx	lr

20000526 <_hook_param>:
void OSC_PARAM(uint16_t index, uint16_t value)
{ 
  Waves::Params &p = s_waves.params;
  Waves::State &s = s_waves.state;
  
  switch (index) {
20000526:	2807      	cmp	r0, #7
20000528:	f200 80ae 	bhi.w	20000688 <_hook_param+0x162>
2000052c:	e8df f000 	tbb	[pc, r0]
20000530:	2e221304 	.word	0x2e221304
20000534:	9f937053 	.word	0x9f937053
  case k_user_osc_param_id1:
    // wave 0
    // select parameter
    {
      static const uint8_t cnt = k_waves_a_cnt + k_waves_b_cnt + k_waves_c_cnt; 
      p.wave0 = value % cnt;
20000538:	4b54      	ldr	r3, [pc, #336]	; (2000068c <_hook_param+0x166>)
2000053a:	202e      	movs	r0, #46	; 0x2e
2000053c:	fbb1 f2f0 	udiv	r2, r1, r0
20000540:	fb00 1112 	mls	r1, r0, r2, r1
      s.flags |= Waves::k_flag_wave0;
20000544:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
  case k_user_osc_param_id1:
    // wave 0
    // select parameter
    {
      static const uint8_t cnt = k_waves_a_cnt + k_waves_b_cnt + k_waves_c_cnt; 
      p.wave0 = value % cnt;
20000548:	f883 1054 	strb.w	r1, [r3, #84]	; 0x54
      s.flags |= Waves::k_flag_wave0;
2000054c:	f042 0202 	orr.w	r2, r2, #2
20000550:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    break;
20000554:	4770      	bx	lr
  case k_user_osc_param_id2:
    // wave 1
    // select parameter
    {
      static const uint8_t cnt = k_waves_d_cnt + k_waves_e_cnt + k_waves_f_cnt; 
      p.wave1 = value % cnt;
20000556:	4b4d      	ldr	r3, [pc, #308]	; (2000068c <_hook_param+0x166>)
20000558:	202c      	movs	r0, #44	; 0x2c
2000055a:	fbb1 f2f0 	udiv	r2, r1, r0
2000055e:	fb00 1112 	mls	r1, r0, r2, r1
      s.flags |= Waves::k_flag_wave1;
20000562:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
  case k_user_osc_param_id2:
    // wave 1
    // select parameter
    {
      static const uint8_t cnt = k_waves_d_cnt + k_waves_e_cnt + k_waves_f_cnt; 
      p.wave1 = value % cnt;
20000566:	f883 1055 	strb.w	r1, [r3, #85]	; 0x55
      s.flags |= Waves::k_flag_wave1;
2000056a:	f042 0204 	orr.w	r2, r2, #4
2000056e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    break;
20000572:	4770      	bx	lr
    
  case k_user_osc_param_id3:
    // sub wave
    // select parameter
    p.subwave = value % k_waves_a_cnt;
20000574:	4b45      	ldr	r3, [pc, #276]	; (2000068c <_hook_param+0x166>)
    s.flags |= Waves::k_flag_subwave;
20000576:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
    break;
    
  case k_user_osc_param_id3:
    // sub wave
    // select parameter
    p.subwave = value % k_waves_a_cnt;
2000057a:	f001 010f 	and.w	r1, r1, #15
    s.flags |= Waves::k_flag_subwave;
2000057e:	f042 0208 	orr.w	r2, r2, #8
    break;
    
  case k_user_osc_param_id3:
    // sub wave
    // select parameter
    p.subwave = value % k_waves_a_cnt;
20000582:	f883 1056 	strb.w	r1, [r3, #86]	; 0x56
    s.flags |= Waves::k_flag_subwave;
20000586:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    break;
2000058a:	4770      	bx	lr
    
  case k_user_osc_param_id4:
    // sub mix
    // percent parameter
    p.submix = clip01f(0.05f + value * 0.01f * 0.90f); // scale in 0.05 - 0.95
2000058c:	ee07 1a90 	vmov	s15, r1
20000590:	ed9f 7a3f 	vldr	s14, [pc, #252]	; 20000690 <_hook_param+0x16a>
20000594:	eddf 6a3f 	vldr	s13, [pc, #252]	; 20000694 <_hook_param+0x16e>
20000598:	eef8 7ae7 	vcvt.f32.s32	s15, s15
2000059c:	ee67 7a87 	vmul.f32	s15, s15, s14
200005a0:	ed9f 7a3d 	vldr	s14, [pc, #244]	; 20000698 <_hook_param+0x172>
200005a4:	eea7 7aa6 	vfma.f32	s14, s15, s13
200005a8:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
200005ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200005b0:	eef0 7a47 	vmov.f32	s15, s14
200005b4:	db09      	blt.n	200005ca <_hook_param+0xa4>
200005b6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
200005ba:	eef4 7ac7 	vcmpe.f32	s15, s14
200005be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200005c2:	bfa8      	it	ge
200005c4:	eef0 7a47 	vmovge.f32	s15, s14
200005c8:	e001      	b.n	200005ce <_hook_param+0xa8>
200005ca:	eddf 7a34 	vldr	s15, [pc, #208]	; 2000069c <_hook_param+0x176>
200005ce:	4b2f      	ldr	r3, [pc, #188]	; (2000068c <_hook_param+0x166>)
200005d0:	edc3 7a10 	vstr	s15, [r3, #64]	; 0x40
    break;
200005d4:	4770      	bx	lr
    
  case k_user_osc_param_id5:
    // ring mix
    // percent parameter
    p.ringmix = clip01f(value * 0.01f);
200005d6:	ee07 1a90 	vmov	s15, r1
200005da:	ed9f 7a2d 	vldr	s14, [pc, #180]	; 20000690 <_hook_param+0x16a>
200005de:	eef8 7ae7 	vcvt.f32.s32	s15, s15
200005e2:	ee67 7a87 	vmul.f32	s15, s15, s14
200005e6:	eef5 7ac0 	vcmpe.f32	s15, #0.0
200005ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200005ee:	db09      	blt.n	20000604 <_hook_param+0xde>
200005f0:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
200005f4:	eef4 7ac7 	vcmpe.f32	s15, s14
200005f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200005fc:	bfa8      	it	ge
200005fe:	eef0 7a47 	vmovge.f32	s15, s14
20000602:	e001      	b.n	20000608 <_hook_param+0xe2>
20000604:	eddf 7a25 	vldr	s15, [pc, #148]	; 2000069c <_hook_param+0x176>
20000608:	4b20      	ldr	r3, [pc, #128]	; (2000068c <_hook_param+0x166>)
2000060a:	edc3 7a11 	vstr	s15, [r3, #68]	; 0x44
    break;
2000060e:	4770      	bx	lr
    
  case k_user_osc_param_id6:
    // bit crush
    // percent parameter
    p.bitcrush = clip01f(value * 0.01f);
20000610:	ee07 1a90 	vmov	s15, r1
20000614:	ed9f 7a1e 	vldr	s14, [pc, #120]	; 20000690 <_hook_param+0x16a>
20000618:	eef8 7ae7 	vcvt.f32.s32	s15, s15
2000061c:	ee67 7a87 	vmul.f32	s15, s15, s14
20000620:	eef5 7ac0 	vcmpe.f32	s15, #0.0
20000624:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000628:	db09      	blt.n	2000063e <_hook_param+0x118>
2000062a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
2000062e:	eef4 7ac7 	vcmpe.f32	s15, s14
20000632:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000636:	bfa8      	it	ge
20000638:	eef0 7a47 	vmovge.f32	s15, s14
2000063c:	e001      	b.n	20000642 <_hook_param+0x11c>
2000063e:	eddf 7a17 	vldr	s15, [pc, #92]	; 2000069c <_hook_param+0x176>
20000642:	4b12      	ldr	r3, [pc, #72]	; (2000068c <_hook_param+0x166>)
    s.flags |= Waves::k_flag_bitcrush;
20000644:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
    break;
    
  case k_user_osc_param_id6:
    // bit crush
    // percent parameter
    p.bitcrush = clip01f(value * 0.01f);
20000648:	edc3 7a12 	vstr	s15, [r3, #72]	; 0x48
    s.flags |= Waves::k_flag_bitcrush;
2000064c:	f042 0220 	orr.w	r2, r2, #32
20000650:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    break;
20000654:	4770      	bx	lr
    
  case k_user_osc_param_shape:
    // 10bit parameter
    p.shape = param_val_to_f32(value);
20000656:	ee07 1a90 	vmov	s15, r1
2000065a:	ed9f 7a11 	vldr	s14, [pc, #68]	; 200006a0 <_hook_param+0x17a>
2000065e:	4b0b      	ldr	r3, [pc, #44]	; (2000068c <_hook_param+0x166>)
20000660:	eef8 7ae7 	vcvt.f32.s32	s15, s15
20000664:	ee67 7a87 	vmul.f32	s15, s15, s14
20000668:	edc3 7a13 	vstr	s15, [r3, #76]	; 0x4c
    break;
2000066c:	4770      	bx	lr
    
  case k_user_osc_param_shiftshape:
    // 10bit parameter
    p.shiftshape = 1.f + param_val_to_f32(value); 
2000066e:	ee07 1a90 	vmov	s15, r1
20000672:	eddf 6a0b 	vldr	s13, [pc, #44]	; 200006a0 <_hook_param+0x17a>
20000676:	4b05      	ldr	r3, [pc, #20]	; (2000068c <_hook_param+0x166>)
20000678:	eef8 7ae7 	vcvt.f32.s32	s15, s15
2000067c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
20000680:	eea7 7aa6 	vfma.f32	s14, s15, s13
20000684:	ed83 7a14 	vstr	s14, [r3, #80]	; 0x50
20000688:	4770      	bx	lr
2000068a:	bf00      	nop
2000068c:	20000800 	.word	0x20000800
20000690:	3c23d70a 	.word	0x3c23d70a
20000694:	3f666666 	.word	0x3f666666
20000698:	3d4ccccd 	.word	0x3d4ccccd
2000069c:	00000000 	.word	0x00000000
200006a0:	3a802008 	.word	0x3a802008

200006a4 <_ZN5Waves5StateC1Ev>:
          float    bitresrcp;
          float    imperfection;
          uint32_t flags:8;
    
    State(void) :
      wave0(wavesA[0]),
200006a4:	4b12      	ldr	r3, [pc, #72]	; (200006f0 <_ZN5Waves5StateC1Ev+0x4c>)
      wave1(wavesD[0]),
200006a6:	4a13      	ldr	r2, [pc, #76]	; (200006f4 <_ZN5Waves5StateC1Ev+0x50>)
          float    bitresrcp;
          float    imperfection;
          uint32_t flags:8;
    
    State(void) :
      wave0(wavesA[0]),
200006a8:	681b      	ldr	r3, [r3, #0]
      lfo(0.f),
      lfoz(0.f),
      dither(0.f),
      bitres(1.f),
      bitresrcp(1.f),
      flags(k_flags_none)
200006aa:	6812      	ldr	r2, [r2, #0]
          float    bitres;
          float    bitresrcp;
          float    imperfection;
          uint32_t flags:8;
    
    State(void) :
200006ac:	b510      	push	{r4, lr}
      lfo(0.f),
      lfoz(0.f),
      dither(0.f),
      bitres(1.f),
      bitresrcp(1.f),
      flags(k_flags_none)
200006ae:	6003      	str	r3, [r0, #0]
200006b0:	6083      	str	r3, [r0, #8]
200006b2:	4b11      	ldr	r3, [pc, #68]	; (200006f8 <_ZN5Waves5StateC1Ev+0x54>)
200006b4:	6042      	str	r2, [r0, #4]
200006b6:	6183      	str	r3, [r0, #24]
200006b8:	61c3      	str	r3, [r0, #28]
200006ba:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
200006be:	4b0f      	ldr	r3, [pc, #60]	; (200006fc <_ZN5Waves5StateC1Ev+0x58>)
200006c0:	6203      	str	r3, [r0, #32]
200006c2:	6302      	str	r2, [r0, #48]	; 0x30
200006c4:	2300      	movs	r3, #0
200006c6:	6342      	str	r2, [r0, #52]	; 0x34
200006c8:	2200      	movs	r2, #0
200006ca:	6243      	str	r3, [r0, #36]	; 0x24
200006cc:	6283      	str	r3, [r0, #40]	; 0x28
200006ce:	62c3      	str	r3, [r0, #44]	; 0x2c
200006d0:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
      imperfection = osc_white() * 1.0417e-006f; // +/- 0.05Hz@48KHz
    }
    
    inline void reset(void)
    {
      phi0 = 0;
200006d4:	60c3      	str	r3, [r0, #12]
      phi1 = 0;
200006d6:	6103      	str	r3, [r0, #16]
      phisub = 0;
200006d8:	6143      	str	r3, [r0, #20]
          float    bitres;
          float    bitresrcp;
          float    imperfection;
          uint32_t flags:8;
    
    State(void) :
200006da:	4604      	mov	r4, r0
200006dc:	f000 f88c 	bl	200007f8 <___osc_white_veneer>
      bitres(1.f),
      bitresrcp(1.f),
      flags(k_flags_none)
    {
      reset();
      imperfection = osc_white() * 1.0417e-006f; // +/- 0.05Hz@48KHz
200006e0:	eddf 7a07 	vldr	s15, [pc, #28]	; 20000700 <_ZN5Waves5StateC1Ev+0x5c>
200006e4:	ee20 0a27 	vmul.f32	s0, s0, s15
    }
200006e8:	4620      	mov	r0, r4
      bitres(1.f),
      bitresrcp(1.f),
      flags(k_flags_none)
    {
      reset();
      imperfection = osc_white() * 1.0417e-006f; // +/- 0.05Hz@48KHz
200006ea:	ed84 0a0e 	vstr	s0, [r4, #56]	; 0x38
    }
200006ee:	bd10      	pop	{r4, pc}
200006f0:	080131e8 	.word	0x080131e8
200006f4:	0801915c 	.word	0x0801915c
200006f8:	3c162fc9 	.word	0x3c162fc9
200006fc:	3b962fc9 	.word	0x3b962fc9
20000700:	358bd08a 	.word	0x358bd08a

20000704 <_GLOBAL__sub_I__hook_init>:
    break;
    
  default:
    break;
  }
}
20000704:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
      phisub = 0;
      lfo = lfoz;
    }
  };

  Waves(void) {
20000708:	4c35      	ldr	r4, [pc, #212]	; (200007e0 <_GLOBAL__sub_I__hook_init+0xdc>)
      bitcrush(0.f),
      shape(0.f),
      shiftshape(0.f),
      wave0(0),
      wave1(0),
      subwave(0)
2000070a:	f8df 90e8 	ldr.w	r9, [pc, #232]	; 200007f4 <_GLOBAL__sub_I__hook_init+0xf0>
2000070e:	b091      	sub	sp, #68	; 0x44
      phisub = 0;
      lfo = lfoz;
    }
  };

  Waves(void) {
20000710:	4620      	mov	r0, r4
20000712:	f7ff ffc7 	bl	200006a4 <_ZN5Waves5StateC1Ev>
      bitcrush(0.f),
      shape(0.f),
      shiftshape(0.f),
      wave0(0),
      wave1(0),
      subwave(0)
20000716:	2500      	movs	r5, #0
20000718:	f04f 0800 	mov.w	r8, #0
  Waves(void) {
    init();
  }

  void init(void) {
    state = State();
2000071c:	4668      	mov	r0, sp
2000071e:	466e      	mov	r6, sp
      bitcrush(0.f),
      shape(0.f),
      shiftshape(0.f),
      wave0(0),
      wave1(0),
      subwave(0)
20000720:	f8c4 9040 	str.w	r9, [r4, #64]	; 0x40
20000724:	6465      	str	r5, [r4, #68]	; 0x44
20000726:	64a5      	str	r5, [r4, #72]	; 0x48
20000728:	64e5      	str	r5, [r4, #76]	; 0x4c
2000072a:	6525      	str	r5, [r4, #80]	; 0x50
2000072c:	f884 8054 	strb.w	r8, [r4, #84]	; 0x54
20000730:	f884 8055 	strb.w	r8, [r4, #85]	; 0x55
20000734:	f884 8056 	strb.w	r8, [r4, #86]	; 0x56
      /**
       * Default constructor
       */
      Coeffs() :
        ff0(0), ff1(0), ff2(0),
        fb1(0), fb2(0)
20000738:	65a5      	str	r5, [r4, #88]	; 0x58
2000073a:	65e5      	str	r5, [r4, #92]	; 0x5c
2000073c:	6625      	str	r5, [r4, #96]	; 0x60
2000073e:	6665      	str	r5, [r4, #100]	; 0x64
20000740:	66a5      	str	r5, [r4, #104]	; 0x68
    /*=====================================================================*/

    /**
     * Default constructor
     */
    BiQuad(void) : mZ1(0), mZ2(0)
20000742:	66e5      	str	r5, [r4, #108]	; 0x6c
20000744:	6725      	str	r5, [r4, #112]	; 0x70
      /**
       * Default constructor
       */
      Coeffs() :
        ff0(0), ff1(0), ff2(0),
        fb1(0), fb2(0)
20000746:	6765      	str	r5, [r4, #116]	; 0x74
20000748:	67a5      	str	r5, [r4, #120]	; 0x78
2000074a:	67e5      	str	r5, [r4, #124]	; 0x7c
2000074c:	f8c4 5080 	str.w	r5, [r4, #128]	; 0x80
20000750:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
    /*=====================================================================*/

    /**
     * Default constructor
     */
    BiQuad(void) : mZ1(0), mZ2(0)
20000754:	f8c4 5088 	str.w	r5, [r4, #136]	; 0x88
20000758:	f8c4 508c 	str.w	r5, [r4, #140]	; 0x8c
  Waves(void) {
    init();
  }

  void init(void) {
    state = State();
2000075c:	f7ff ffa2 	bl	200006a4 <_ZN5Waves5StateC1Ev>
20000760:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
20000762:	4627      	mov	r7, r4
20000764:	c70f      	stmia	r7!, {r0, r1, r2, r3}
20000766:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
20000768:	c70f      	stmia	r7!, {r0, r1, r2, r3}
2000076a:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
2000076c:	c70f      	stmia	r7!, {r0, r1, r2, r3}
2000076e:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
20000772:	c707      	stmia	r7!, {r0, r1, r2}
20000774:	703b      	strb	r3, [r7, #0]
       *
       * @param   pole Pole position in radians
       */
      inline __attribute__((optimize("Ofast"),always_inline))
      void setPoleLP(const float pole) {
        ff0 = 1.f - pole;
20000776:	4b1b      	ldr	r3, [pc, #108]	; (200007e4 <_GLOBAL__sub_I__hook_init+0xe0>)
    params = Params();
20000778:	f8c4 9040 	str.w	r9, [r4, #64]	; 0x40
2000077c:	65a3      	str	r3, [r4, #88]	; 0x58
        fb1 = -pole;
2000077e:	4b1a      	ldr	r3, [pc, #104]	; (200007e8 <_GLOBAL__sub_I__hook_init+0xe4>)
20000780:	6663      	str	r3, [r4, #100]	; 0x64
   * @note Not checking input, caller responsible for bounding x.
   */
  __fast_inline float osc_tanpif(float x) {
    const float idxf = x * k_tanpi_range_recip * k_tanpi_size;
    const uint32_t idx = (uint32_t)idxf;
    const float y0 = tanpi_lut_f[idx];
20000782:	4b1a      	ldr	r3, [pc, #104]	; (200007ec <_GLOBAL__sub_I__hook_init+0xe8>)

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000784:	eddf 6a1a 	vldr	s13, [pc, #104]	; 200007f0 <_GLOBAL__sub_I__hook_init+0xec>
20000788:	edd3 7aeb 	vldr	s15, [r3, #940]	; 0x3ac
2000078c:	ed93 7aec 	vldr	s14, [r3, #944]	; 0x3b0
20000790:	6465      	str	r5, [r4, #68]	; 0x44
20000792:	ee37 7a67 	vsub.f32	s14, s14, s15
20000796:	64a5      	str	r5, [r4, #72]	; 0x48
20000798:	eee7 7a26 	vfma.f32	s15, s14, s13
2000079c:	64e5      	str	r5, [r4, #76]	; 0x4c
2000079e:	6525      	str	r5, [r4, #80]	; 0x50
       *
       * @param   k Tangent of PI x cutoff frequency in radians: tan(pi*wc)
       */
      inline __attribute__((optimize("Ofast"),always_inline))
      void setFOLP(const float k) {
        const float kp1 = k+1.f;
200007a0:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
200007a4:	ee37 7aa6 	vadd.f32	s14, s15, s13
200007a8:	f884 8054 	strb.w	r8, [r4, #84]	; 0x54
        const float km1 = k-1.f;
        ff0 = ff1 = k / kp1;
200007ac:	ee87 6a87 	vdiv.f32	s12, s15, s14
200007b0:	f884 8055 	strb.w	r8, [r4, #85]	; 0x55
200007b4:	f884 8056 	strb.w	r8, [r4, #86]	; 0x56
       */
      inline __attribute__((optimize("Ofast"),always_inline))
      void setPoleLP(const float pole) {
        ff0 = 1.f - pole;
        fb1 = -pole;
        fb2 = ff2 = ff1 = 0.f;
200007b8:	65e5      	str	r5, [r4, #92]	; 0x5c
200007ba:	6625      	str	r5, [r4, #96]	; 0x60
200007bc:	66a5      	str	r5, [r4, #104]	; 0x68
      void setFOLP(const float k) {
        const float kp1 = k+1.f;
        const float km1 = k-1.f;
        ff0 = ff1 = k / kp1;
        fb1 = km1 / kp1;
        fb2 = ff2 = 0.f;
200007be:	67e5      	str	r5, [r4, #124]	; 0x7c
200007c0:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
      inline __attribute__((optimize("Ofast"),always_inline))
      void setFOLP(const float k) {
        const float kp1 = k+1.f;
        const float km1 = k-1.f;
        ff0 = ff1 = k / kp1;
        fb1 = km1 / kp1;
200007c4:	ee77 7ae6 	vsub.f32	s15, s15, s13
       */
      inline __attribute__((optimize("Ofast"),always_inline))
      void setFOLP(const float k) {
        const float kp1 = k+1.f;
        const float km1 = k-1.f;
        ff0 = ff1 = k / kp1;
200007c8:	ed84 6a1e 	vstr	s12, [r4, #120]	; 0x78
        fb1 = km1 / kp1;
200007cc:	eec7 6a87 	vdiv.f32	s13, s15, s14
       */
      inline __attribute__((optimize("Ofast"),always_inline))
      void setFOLP(const float k) {
        const float kp1 = k+1.f;
        const float km1 = k-1.f;
        ff0 = ff1 = k / kp1;
200007d0:	ed84 6a1d 	vstr	s12, [r4, #116]	; 0x74
        fb1 = km1 / kp1;
200007d4:	edc4 6a20 	vstr	s13, [r4, #128]	; 0x80
200007d8:	b011      	add	sp, #68	; 0x44
200007da:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
200007de:	bf00      	nop
200007e0:	20000800 	.word	0x20000800
200007e4:	3e4ccccc 	.word	0x3e4ccccc
200007e8:	bf4ccccd 	.word	0xbf4ccccd
200007ec:	0800f764 	.word	0x0800f764
200007f0:	3dd0f800 	.word	0x3dd0f800
200007f4:	3d4ccccd 	.word	0x3d4ccccd

200007f8 <___osc_white_veneer>:
200007f8:	f85f f000 	ldr.w	pc, [pc]	; 200007fc <___osc_white_veneer+0x4>
200007fc:	0801edb9 	.word	0x0801edb9
